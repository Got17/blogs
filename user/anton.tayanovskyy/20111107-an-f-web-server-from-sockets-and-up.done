---
title: "An F# Web Server From Sockets and Up"
categories: "f#,sockets,performance,webserver"
abstract: "I have implemented a simple web server in F#.  The idea was to try to marry .NET asynchronous socket operations with F# async. <b>Result</b>: F# async seems to be the right tool for the job of webserver implementation: it makes asynchronous programming intuitive without adding too much performance overhead.  The server executes 3500 keep-alive or 1000 normal request per second on my Core i3 machine, compared to 2500/500 requests per second using IIS or <code>System.Net.HttpListener</code>.<br /><br /><h4>Asynhronous Socket Operations</h4><br />Working with sockets in .NET is done with the <code>Socket</code> <a href=\"http://msdn.microsoft.com/en-us/library/system.net.sockets.socket.aspx\">class</a>.  From the MSDN documentation, the recommended approach is to use the asynchronous methods such as <code>AcceptAsync</code>, <code>SendAsync</code> and <code>ReceiveAsync</code>. These methods register callbacks to be executed when data arrives or ships through the socket.  As a result of the callback approach, no threads are blocked by slow connections.<br /><br /><h4>Sockets and F# Async</h4><br />Unfortunately, the default interface is not very intuitive.  The example code is atrocious.  Since the operations are callback-based, this seems like a good match for<br />F# async.  I went for the first mapping that came to mind:<br /><br /><script src=\"https://gist.github.com/1346379.js?file=AsyncSockets.fsi\"></script><br /><br />Implementing this interface is easy - it is just working around the boilerplate: creating a <code>SocketAsyncEventArgs</code> object, registering a callback, calling the method, checking the result for errors.  I was able to express all of it in a single helper method:<br /><br /><script src=\"https://gist.github.com/1346379.js?file=AsyncSockets.fs\"></script><br /><br /><h4>Optimizations</h4><br />It seems that the common optimization paths include pooling sockets, pooling <code>SocketAsyncEventArgs</code>, and pooling buffers to prevent memory fragmentation.  The latest point is the most interesting.  Socket code itself is written in unmanaged C and passing data between garbage-collected .NET code and C code is done by <i>pinning</i> the .NET array used as a buffer.  A pinned array is never relocated by the garbage collector, so the C code<br />has no trouble finding it.  A lot of pinned arrays to work around make garbage collector's job harder - memory gets fragmented.<br /><br />To avoid fragmentation issues, instead of allocating a lot of small arrays I allocate one huge array and then lease sections of it to be used as buffers by the socket operations.<br /><br />I have not yet tried pooling `Socket` or `SocketAsyncEventArgs` objects in a similar manner.<br /><br /><h4>Benchmarks</h4><br />For benchmarking I have used Apache Bench (ab) tool running on Arch Linux inside a VirtualBox VM.  All benchmarks involved dynamically generating and serving a \"HELLO, WORLD\" document on my Core i3 laptop, with <code>ab -k -c 1000 -n 10000</code>:<br /><br /><table><tr><th>Server</th><th>Keep-alive r/s</th><th>Regular r/s</th></tr><tr><td>F# WebServer</td><td>3500</td><td>1000</td></tr><tr><td>Haskell warp/wai GHC 7</td><td>3500</td><td>3500</td></tr><tr><td>IIS</td> <td>2500</td><td>500</td></tr><tr><td>System.Net.HttpListener</td><td>?</td><td>500</td></tr><tr><td>node.js (Windows)</td><td>800</td><td>400</td></tr><tr><td>node.js (Linux)</td><td>?</td><td>3000</td></tr></table><br />I do not feel very good about these numbers, in particular because I have seen claims of Haskell WARP doing 90000 r/s on only slightly faster hardware (8-core Core i5).  It may be that I am hitting VirtualBox networking overhead or I have not built the Haskell code with proper flags.<br /><br />But for what they are worth, the numbers seem to indicate that F# async is a good enough foundation for web servers with performance in the IIS league.  It does not need to be faster, it just needs to be good enough.  The real advantage is that F# async code is tremendously easier to read and write than explicit callback code.<br /><br /><b>EDIT</b>: Please do take the benchmarks with a grain of salt. They are far from comprehensive or correctly done.<div class=\"blogger-post-footer\"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/6028449519062514692-4749549117969455907?l=t0yv0.blogspot.com' alt='' /></div>"
identity: "2071,74903"
---
